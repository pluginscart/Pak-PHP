<?php

namespace UtilitiesFramework;

/**
 * Used to handle errors and exceptions
 * 
 * Contains functions that can be registered as error handler, exception handler and shutdown function
 * The handler functions basically all work in the same way. i.e they log the error message
 * The error logging can be configured using parameters passed to the object constructor
 * 
 * @category   Utilities
 * @package    UtilitiesFramework
 * @author     Nadir Latif <nadir@pakjiddat.com>
 * @license    https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License, version 2
 * @version    Release: 1.0.0
 * @link       N.A
 */
class ErrorHandler
{
    /**
     * The single static instance
     */
    protected static $instance;
    /**
     * Contains the error level. e.g E_WARNING
     */
    private $error_level;
    /**
     * Contains detailed error information
     * Includes error message, error file name, error line number and error context		 
     */
    private $error_message, $error_file, $error_line, $error_context;
    /**
     * The email address of the user who should get the error notification
     */
    private $user_email;
    /**
     * The name of the file where error messages should be logged
     */
    private $log_file_name;
    /**
     * The type of the error. i.e error or exception
     */
    private $type;
    /**
     * The SMTP headers to be included with the error email
     */
    private $log_email_header;
    /**
     * The original exception object that raised the first exception
     */
    private $first_exception_obj;
    /**
     * The exception object included with the exception
     */
    private $exception_obj;
    /**
     * Used to indicate if the current application is run from the browser or from the command line		 
     */
    private $is_browser_application;
    /**
     * Used to call a custom error handling function. It is an array with 2 keys:
     * object=> object containing the error handling function
     * function=> the error handling function. it takes 2 parameters
     * the error trace generated by the logging class and the error details array
     * the error details array has following keys=>
     * 
     */
    private $custom_error_handler;
    /**
     * Used to indicate if the error message should be displayed to the user
     */
    private $display_error;
    
    /**
     * Used to return a single instance of the class
     * 
     * Checks if instance already exists
     * If it does not exist then it is created
     * The instance is returned
     * 
     * @since 1.0.0
     * @param array $parameters it contains the configuration information for the logging class object. it should have following keys:		
     * log_email=> the email address at which to sent error notification
     * log_file_name=> the name of the log file to which the error will be logged
     * log_email_header=> the smtp headers to include in the log email		 
     * display_error=> used to indicate if the error message should be displayed to the user
     * is_browser_application=> used to indicate if class is being used by a browser application
     * custom_error_handler=> used to specify a custom error handling function. it will be called when there is an error or exception. it is an array with 2 keys
     *  					  first is the object the second is the name of the function that will handle the error
     * 						  this function should exist within the object
     * shutdown_function=> used to specify a custom shutdown function. it will be called when the current script ends. it is an array with 2 keys
     *  					  first is the object the second is the name of the function that will be called
     * 						  this function should exist within the object 
     * 
     * @return ErrorHandler static::$instance name the single instance of the class is returned
     */
    public static function GetInstance($parameters)
    {        
        if (self::$instance == null) {
            self::$instance = new self($parameters);
        }
        return self::$instance;        
    }
    
    /**
     * Class constructor
     * Used to prevent creating an object of this class outside of the class using new operator
     * 
     * Used to implement Singleton class
     * Used to initialize the object variables from the constructor parameters
     * 
     * @since 1.0.0		 
     * @param array $parameters it contains the configuration information for the logging class object. it should have following keys:		 
     * log_email=> the email address at which to sent error notification
     * log_file_name=> the name of the log file to which the error will be logged
     * log_email_header=> the smtp headers to include in the log email		 
     * display_error=> used to indicate if the error message should be displayed to the user
     * is_browser_application=> used to indicate if class is being used by a browser application
     * custom_error_handler=> used to specify a custom error handling function. it will be called when there is an error or exception. it is an array with 2 keys
     *  					  first is the object the second is the name of the function that will handle the error
     * 						  this function should exist within the object
     * shutdown_function=> used to specify a custom shutdown function. it will be called when the current script ends. it is an array with 2 keys
     *  					  first is the object the second is the name of the function that will be called
     * 						  this function should exist within the object 
     */
    protected function __construct($parameters)
    {
    	/** Object properties are set to the constructor parameters */
        $this->user_email             = $parameters['log_email'];
        $this->log_file_name          = $parameters['log_file_name'];
        $this->log_email_header       = $parameters['log_email_header'];
        $this->display_error          = $parameters['display_error'];
        $this->custom_error_handler   = $parameters['custom_error_handler'];
        $this->type                   = "";
        $this->is_browser_application = (isset($_SERVER['HTTP_HOST']) || isset($_SERVER['HTTPS_HOST'])) ? true : false;
		        
        /** The error handler, exception handler and shutdown handler functions are registered */
        set_error_handler(array(
            $this,
            "ErrorHandler"
        ));
        set_exception_handler(array(
            $this,
            "ExceptionHandler"
        ));
        register_shutdown_function(array(
            $this,
            "ShutdownFunction"
        ));
        
        if (isset($parameters['shutdown_function']) && $parameters['shutdown_function']!="" && !(is_callable($parameters['shutdown_function'])))
            throw new \Exception("Invalid custom shutdown function");
        else if($parameters['shutdown_function']!="")
            register_shutdown_function($parameters['shutdown_function']);                       
    }
    
    /**
     * Error handling function
     * 
     * The function can be registered as an error handler using set_error_handler php function
     * The function sets the error variables of the object and logs the error		 
     * 
     * @since 1.0.0
     * 
     * @param int $error_level the error level
     * @param string $error_message the error message
     * @param string $error_file the error file name
     * @param int $error_line the error line number
     * @param array $error_context the error context
     */
    public function ErrorHandler($error_level, $error_message, $error_file, $error_line, $error_context)
    {        
        /** The object error properties are set to the error information **/
        $this->error_level   = $error_level;
        $this->error_message = $error_message;
        $this->error_file    = $error_file;
        $this->error_line    = $error_line;
        $this->error_context = $error_context;
        $this->type          = "Error";
        /** The error message is logged **/
        $this->LogError();        
    }
    
    /**
     * Exception handling function
     * 
     * The function can be registered as an exception handler using set_exception_handler php function
     * The function sets the error variables of the object including the object that raised the exception and logs the error
     * 
     * @since 1.0.0		 
     * @param object $exception_obj the exception object that contains the error information
     */
    public function ExceptionHandler($exception_obj)
    {        
        /** The last exception object is set to the exception_obj property **/
        $this->exception_obj = $exception_obj;
        /** The first object that raised the exception is fetched **/
        $temp_exception_obj  = $exception_obj;
        while ($e = $temp_exception_obj->getPrevious())
            $temp_exception_obj = $e;
        $this->first_exception_obj = $temp_exception_obj;
        
        /** The exception properties of the class are set **/
        $log_message         = "";
        $response            = array(
            "result" => "error",
            "data" => $temp_exception_obj->getMessage()
        );
        $this->exception_obj = $temp_exception_obj;
        $this->error_level   = $temp_exception_obj->getCode();
        $this->error_message = $temp_exception_obj->getMessage();
        $this->error_file    = $temp_exception_obj->getFile();
        $this->error_line    = $temp_exception_obj->getLine();
        $this->error_context = $temp_exception_obj->getTrace();
        $this->type          = "Exception";
        /** The exception is logged **/
        $this->LogError();        
    }
    
    /**
     * Shutdown function
     * 
     * This function can be registered as a shutdown handling function. It can be registered with the register_shutdown_function php function
     * This function is called after the script execution ends
     * If the script has an error or exception that was not handled before then this function can handle the error/exception		  		
     */
    public function ShutdownFunction()
    {        
        /** The last error message is fetched **/
        $error = error_get_last();
        /** If there was an error then it is handled using the ErrorHandler function **/
        if (isset($error["type"]))
            $this->ErrorHandler($error["type"], $error["message"], $error["file"], $error["line"], "Fatal error in script");        
    }
    
    /**
     * Get Parameter information
     * 
     * Used to get the function parameter information for a stack trace entry
     * 
     * @param array $trace the stack trace entry for which the function parameters are required
     * @param string $class_name name of the class that includes the function
     * @param string $function_name name of the function whose parameter information is needed
	 * 
	 * @return array $extra_error_message an array containing formatted function parameter information
     */
    private function GetParameterInformation($trace, $class_name, $function_name)
    {       
        $extra_error_message = array();
        
        for ($count = 0; $count < count($trace['args']); $count++) {
            /** Gets function parameter value from stack trace **/
            $parameter_value = $trace['args'][$count];
            /** If parameter value is an array then it is converted to string **/
            if (is_array($parameter_value))
                $parameter_value = var_export($parameter_value, true);
            /** Gets function parameter name from ReflectionParameter class **/
            $parameters_information = new \ReflectionParameter(array(
                $class_name,
                $function_name
            ), $count);
            $parameters_name        = $parameters_information->getName();
            if (is_object($parameter_value))
                $parameter_value = "Object of class: " . get_class($parameter_value);
            /** Adds the function parameter information to the error array **/
            $extra_error_message[] = "\t\t" . ($count + 1) . ") " . $parameters_name . ": " . $parameter_value;
        }
        /** The parameter information is formatted for browser **/
        if ($this->is_browser_application && count($trace['args']) > 0) {
            $parameter_div_start_index                       = (count($extra_error_message) - count($trace['args']));
            $parameter_div_end_index                         = (count($extra_error_message));
            $extra_error_message[$parameter_div_start_index] = "<div style='color: blue;margin-left:2%;'>" . $extra_error_message[$parameter_div_start_index];
            $extra_error_message[$parameter_div_end_index - 1] .= "</div>";
        }
        return $extra_error_message;        
    }
    
    /**
     * This function is used to format error message text
     * 
     * It breaks down the error message stack and displays the error messages in numbered format
     * 
     * @param object $exception_obj the exception object that contains the error information
	 * 
	 * @return array $extra_error_message_text the complete formatted error message
     */
    private function FormatErrorMessage($exception_obj)
    {        
        if (!is_object($exception_obj))
            throw new \Exception("Invalid exception parameter passed to FormatErrorMessage function", 100);
        
        /** The function local variables are initialized **/
        $extra_error_message      = array();
        $extra_error_message_text = "";
        $line_break               = ($this->is_browser_application) ? "<br/>" : "\n";
        
        /** The stack trace of the first exception object is fetched. This object contains the entire stack trace **/
        $stack_trace = $this->first_exception_obj->getTrace();
        /** Information of each stack trace is added to an array. The information is formatted for web browsers **/
        for ($count = 0; $count < count($stack_trace); $count++) {
            $trace = $stack_trace[$count];
            /** 
             * The short file name is extracted if file information is available
             * The file information is not available for exceptions thrown inside functions
             * Without a class 
             */
            if (isset($trace['file'])) {
                $temp_arr        = explode(DIRECTORY_SEPARATOR, $trace['file']);
                $short_file_name = $temp_arr[count($temp_arr) - 1];
            } else
                $short_file_name = "N.A";
            
            $line                  = (isset($trace['line'])) ? $trace['line'] : "N.A";
            $function              = $trace['function'];
            $class                 = (isset($trace['class'])) ? $trace['class'] : "N.A";
            $extra_error_message[] = ($count + 1) . ") \tFunction " . ($count + 1);
            if ($this->is_browser_application)
                $extra_error_message[] = "<div style='color: green;margin-left:2%;'>" . "\ta) File name: " . $short_file_name;
            else
                $extra_error_message[] = "\ta) File name: " . $short_file_name;
            $extra_error_message[] = "\tb) Line: " . $line;
            $extra_error_message[] = "\tc) Function: " . $function;
            $extra_error_message[] = "\td) Parameters: ";
            /** 
             * The function parameter information is fetched if the class information is available
             * The file information is not available for exceptions thrown inside functions
             * Without a class  
             */
            if ($class != "N.A") {
                $parameter_information = $this->GetParameterInformation($trace, $class, $function);
                $extra_error_message   = array_merge($extra_error_message, $parameter_information);
                if ($this->is_browser_application)
                    $extra_error_message[count($extra_error_message) - 1] = "\te) Class: " . $class . "</div>";
                else
                    $extra_error_message[] = "\te) Class: " . $class;
            } else {
                $extra_error_message[count($extra_error_message) - 1] .= "N.A";
                if ($this->is_browser_application)
                    $extra_error_message[] = "\te) Class: N.A</div>";
                else
                    $extra_error_message[] = "\te) Class: N.A";
            }
            if (!$this->is_browser_application)
                $extra_error_message[] = "";
        }
        $extra_error_message_text = implode($line_break, $extra_error_message);
        
        return $extra_error_message_text;        
    }
    
    /**
     * Logging function
     * 
     * This function is used to log errors
     * The function saves the error to a log file and optionally emails the error to the user
     * The error message is also echoed		  		
     */
    public function LogError()
    {        
        $log_message = "";
        /** The log message is formatted for web browsers **/
        if ($this->is_browser_application) {
            $log_message = "<b>Exception on:</b> <span style='color:red'>" . date("d-m-Y H:i:s") . "</span>";
            $log_message .= "<br/><b>Error Code:</b> <span style='color:red'>" . $this->error_level . "</span>";
            $log_message .= "<br/><b>Error File:</b> <span style='color:red'>" . $this->error_file . "</span>";
            $log_message .= "<br/><b>Error Line:</b> <span style='color:red'>" . $this->error_line . "</span>";
            $log_message .= "<br/><b>Error Message:</b> <span style='color:red'>" . $this->error_message . "</span>";
            if (is_object($this->exception_obj))
                $log_message .= "<br/><br/><b>Stack Trace:</b> <span style='color:red'><br/><br/>" . $this->FormatErrorMessage($this->exception_obj) . "</span>";
        } else {
            $log_message = "Exception on: " . date("d-m-Y H:i:s");
            $log_message .= "\nError Code: " . $this->error_level;
            $log_message .= "\nFile:" . $this->error_file;
            $log_message .= "\nLine:" . $this->error_line;
            $log_message .= "\n\nError Message:" . $this->error_message;
            if (is_object($this->exception_obj))
                $log_message .= "\n\nStack Trace: \n\n" . $this->FormatErrorMessage($this->exception_obj);
        }
        /** The log message is written to log file if log file name is given **/
        if ($this->log_file_name != "")
            error_log($log_message, 3, $this->log_file_name);
        /** The log message is sent as email if the email address is given **/
        if ($this->user_email != "")
            error_log($log_message, 1, $this->user_email, $this->log_email_header);
        /** 
         * The log message is displayed to the browser if the display_error option is true 
         * If display_error is false then a simple error message is displayed is displayed as an alert
         */
        if ($this->display_error) {
            /** 
             * If a custom error handling function is defined then it is called
             * The log message and error details are given as arguments
             */
            if (is_callable($this->custom_error_handler)) {
                $error_parameters = array(
                    "error_level" => $this->error_level,
                    "error_message" => $this->error_message,
                    "error_file" => $this->error_file,
                    "error_line" => $this->error_line,
                    "error_context" => $this->error_context,
                    "error_type" => $this->type
                );
                
                /** calls the user defined error handler if one is defined **/
                call_user_func_array($this->custom_error_handler, array(
                    $log_message,
                    $error_parameters
                ));
                
            }
            /** If the custom error handler is defined but is not valid then an exception is thrown **/
            else if ($this->custom_error_handler != "")
                throw new \Exception("Invalid custom error handler type given", 100);
            /** If the custom error handling function is not defined then the log message is echoed **/
            else
                echo $log_message;
        } else if ($this->is_browser_application)
            echo "<script>alert('An error has occured in the application. Please contact the system administrator');</script>";
        else
            echo "An error has occured in the application. Please contact the system administrator";
        
        exit;        
    }
}

?>